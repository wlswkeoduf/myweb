<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÎèÑÌä∏ Í≤åÏûÑ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #243b55 0%, #141e30 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        .game-container {
            text-align: center;
            padding: 10px;
            width: 100%;
            max-width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        h1 {
            color: #ecf0f1;
            margin-bottom: 5px;
            font-size: clamp(18px, 4vw, 28px);
        }

        .top-ui {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 0 10px;
        }

        .score-display {
            color: #ecf0f1;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            min-width: 120px;
        }

        .score-row {
            display: flex;
            align-items: baseline;
            gap: 6px;
            background: rgba(52, 73, 94, 0.4);
            padding: 2px 8px;
            border-radius: 6px;
            border: 1px solid rgba(236, 240, 241, 0.2);
        }

        .score-label {
            font-size: clamp(10px, 2.4vw, 12px);
            color: #bdc3c7;
        }

        .score-value {
            font-size: clamp(16px, 4vw, 20px);
            color: #f1f2f6;
        }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            max-height: 600px;
            aspect-ratio: 800 / 600;
        }

        canvas {
            width: 100%;
            height: 100%;
            border: 4px solid #34495e;
            background: radial-gradient(circle at 50% 30%, #3cb474 0%, #1e8449 70%, #145a32 100%);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
        }

        .info {
            margin-top: 10px;
            color: #ecf0f1;
            font-size: clamp(12px, 3vw, 16px);
        }

        .health-bar-container {
            width: min(280px, 55vw);
            height: 28px;
            background: linear-gradient(180deg, #2c3e50 0%, #34495e 100%);
            border: 3px solid #1a252f;
            border-radius: 6px;
            position: relative;
            flex: 1;
            margin: 0 10px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .health-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60 0%, #2ecc71 50%, #27ae60 100%);
            background-size: 20px 100%;
            transition: width 0.3s ease;
            width: 100%;
            border-radius: 4px;
            box-shadow: 0 0 8px rgba(46, 204, 113, 0.4);
            position: relative;
            overflow: hidden;
        }

        .health-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.2) 50%, transparent 100%);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .health-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: clamp(11px, 2.8vw, 13px);
            font-weight: bold;
            z-index: 2;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8), 0 0 4px rgba(0, 0, 0, 0.5);
            letter-spacing: 0.5px;
        }

        .weapon-display {
            color: #f39c12;
            font-size: clamp(12px, 3vw, 16px);
            font-weight: bold;
            min-width: 80px;
            text-align: right;
        }

        .controls {
            margin-top: 10px;
            color: #bdc3c7;
            font-size: clamp(10px, 2.5vw, 14px);
        }

        .character-select-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(6px);
            background: rgba(20, 30, 48, 0.85);
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .character-select-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .character-select-panel {
            background: rgba(26, 40, 60, 0.95);
            border: 2px solid rgba(236, 240, 241, 0.25);
            border-radius: 16px;
            padding: clamp(20px, 5vw, 40px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(16px, 4vw, 24px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
            max-width: 90vw;
        }

        .character-select-title {
            color: #ecf0f1;
            font-size: clamp(18px, 4vw, 26px);
            font-weight: bold;
            letter-spacing: 1px;
        }

        .character-options {
            display: flex;
            gap: clamp(12px, 4vw, 24px);
            flex-wrap: wrap;
            justify-content: center;
        }

        .character-option {
            width: clamp(90px, 25vw, 140px);
            height: clamp(120px, 35vw, 180px);
            border-radius: 16px;
            border: 2px solid rgba(236, 240, 241, 0.2);
            background: rgba(44, 62, 80, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: #ecf0f1;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .character-option::before {
            content: '';
            position: absolute;
            inset: -40%;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.15), transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .character-option:hover {
            transform: translateY(-6px) scale(1.03);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
        }

        .character-option:hover::before {
            opacity: 1;
        }

        .character-option.selected {
            border-color: #f1c40f;
            box-shadow: 0 0 25px rgba(241, 196, 15, 0.4);
        }

        .character-name {
            font-size: clamp(14px, 3.5vw, 18px);
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .character-description {
            font-size: clamp(10px, 2.8vw, 12px);
            color: #bdc3c7;
            text-align: center;
            padding: 0 12px;
        }

        .character-sample {
            width: clamp(50px, 12vw, 70px);
            height: clamp(50px, 12vw, 70px);
            position: relative;
            display: block;
            border-radius: 8px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            background: rgba(0, 0, 0, 0.2);
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            pointer-events: none !important;
        }
        
        .character-option[data-character="blue"] .character-sample {
            border-radius: 4px;
        }
        
        .character-option[data-character="violet"] .character-sample {
            border-radius: 50%;
        }
        
        .character-option[data-character="pink"] .character-sample {
            border-radius: 0;
        }

        .character-select-hint {
            font-size: clamp(10px, 2.5vw, 12px);
            color: #95a5a6;
        }

        .game-over-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(10, 15, 25, 0.85);
            backdrop-filter: blur(6px);
            z-index: 210;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .game-over-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .game-over-panel {
            background: rgba(26, 40, 60, 0.95);
            border: 2px solid rgba(236, 240, 241, 0.25);
            border-radius: 18px;
            padding: clamp(24px, 6vw, 48px);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: clamp(18px, 4vw, 28px);
            box-shadow: 0 16px 44px rgba(0, 0, 0, 0.45);
            width: min(90vw, 420px);
        }

        .game-over-title {
            color: #f8f9fa;
            font-size: clamp(20px, 5vw, 30px);
            font-weight: bold;
            letter-spacing: 1px;
        }

        .game-over-score {
            width: 100%;
            background: rgba(52, 73, 94, 0.6);
            border-radius: 14px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border: 1px solid rgba(236, 240, 241, 0.15);
            color: #ecf0f1;
        }

        .score-line {
            display: flex;
            justify-content: space-between;
            font-size: clamp(14px, 3.8vw, 18px);
        }

        .score-line span:first-child {
            color: #bdc3c7;
        }

        .game-over-buttons {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .game-over-button {
            background: linear-gradient(135deg, #3498db, #1abc9c);
            border: none;
            color: #ecf0f1;
            padding: 12px 22px;
            border-radius: 999px;
            font-size: clamp(12px, 3.2vw, 16px);
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 6px 18px rgba(26, 188, 156, 0.35);
        }

        .game-over-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 22px rgba(26, 188, 156, 0.45);
        }

        .game-over-button.secondary {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 6px 18px rgba(155, 89, 182, 0.35);
        }

        .game-over-button.secondary:hover {
            box-shadow: 0 10px 22px rgba(155, 89, 182, 0.45);
        }

        /* Î™®Î∞îÏùº Ïª®Ìä∏Î°§ */
        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            z-index: 100;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .joystick-container {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 120px;
            height: 120px;
        }

        .joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(52, 73, 94, 0.7);
            border: 3px solid rgba(236, 240, 241, 0.5);
            position: relative;
        }

        .joystick-stick {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(52, 152, 219, 0.8);
            border: 2px solid rgba(236, 240, 241, 0.8);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: transform 0.1s;
        }

        .attack-button {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.8);
            border: 3px solid rgba(236, 240, 241, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #ecf0f1;
            font-weight: bold;
            user-select: none;
            touch-action: none;
        }

        .attack-button:active {
            background: rgba(192, 57, 43, 0.9);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            body {
                align-items: flex-start;
                padding: 0;
            }

            .game-container {
                justify-content: flex-start;
                padding-top: 8px;
                padding-bottom: calc(100vh * 0.34);
                padding-left: 10px;
                padding-right: 10px;
                gap: 8px;
                width: 100%;
                max-width: 100vw;
            }

            .top-ui {
                padding: 0 8px;
                width: 100%;
                max-width: 100%;
                gap: 8px;
            }

            .canvas-wrapper {
                max-height: calc(100vh * 0.66);
                width: 100%;
                margin: 0 auto;
            }

            .health-bar-container {
                margin: 0 4px;
            }

            .mobile-controls {
                display: flex;
                justify-content: space-between;
                align-items: center;
                top: calc(100vh * 0.68);
                bottom: auto;
                left: 50%;
                transform: translateX(-50%);
                width: min(90vw, 600px);
                max-width: 90vw;
                padding: 12px 20px;
                gap: 20px;
            }

            .joystick-container {
                position: relative;
                left: auto;
                bottom: auto;
                flex: 0 0 auto;
            }

            .attack-button {
                position: relative;
                right: auto;
                bottom: auto;
                margin-left: auto;
                flex: 0 0 auto;
            }
            
            .controls {
                display: none;
            }

            h1 {
                margin-bottom: 4px;
            }
        }
    </style>
</head>
<body>
    <div class="character-select-overlay show" id="characterSelect">
        <div class="character-select-panel">
            <div class="character-select-title">Î™®ÌóòÏùÑ Îñ†ÎÇ† ÏòÅÏõÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!</div>
            <div class="character-options">
                <div class="character-option" data-character="blue">
                    <canvas class="character-sample" data-shape="square" width="70" height="70"></canvas>
                    <div class="character-name">Í∏∞ÏÇ¨</div>
                    <div class="character-description">Ï≤¥Î†•Ïù¥ ÎÜíÍ≥† ÏÜçÎèÑÍ∞Ä Îπ†Î•∏ Ï∫êÎ¶≠ÌÑ∞ ÏûÖÎãàÎã§.</div>
                </div>
                <div class="character-option" data-character="violet">
                    <canvas class="character-sample" data-shape="circle" width="70" height="70"></canvas>
                    <div class="character-name">Í∂ÅÏàò</div>
                    <div class="character-description">Î≥¥ÌÜµÏùò Îä•Î†• Ï∫êÎ¶≠ÌÑ∞ ÏûÖÎãàÎã§.</div>
                </div>
                <div class="character-option" data-character="pink">
                    <canvas class="character-sample" data-shape="star" width="70" height="70"></canvas>
                    <div class="character-name">ÎßàÎ≤ïÏÇ¨</div>
                    <div class="character-description">Ï≤¥Î†•Ïù¥ ÎÇÆÍ≥† ÏÜçÎèÑÍ∞Ä ÎäêÎ¶¨ÏßÄÎßå Í∞ïÌïú Ï∫êÎ¶≠ÌÑ∞ ÏûÖÎãàÎã§.</div>
                </div>
            </div>
            <div class="character-select-hint">Ï∫êÎ¶≠ÌÑ∞Î•º ÌÉ≠ÌïòÍ±∞ÎÇò ÌÅ¥Î¶≠ÌïòÎ©¥ Í≤åÏûÑÏù¥ ÏãúÏûëÎê©ÎãàÎã§.</div>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-panel">
            <div class="game-over-title">Í≤åÏûÑ Ïò§Î≤Ñ</div>
            <div class="game-over-score">
                <div class="score-line"><span>Ïù¥Î≤à Ï†êÏàò</span><span id="finalScore">0</span></div>
                <div class="score-line"><span>ÏßÄÎÇú Ï†êÏàò</span><span id="gameOverPreviousScore">0</span></div>
            </div>
            <div class="game-over-buttons">
                <button class="game-over-button" id="restartButton">Îã§Ïãú ÏãúÏûë</button>
                <button class="game-over-button secondary" id="changeCharacterButton">Ï∫êÎ¶≠ÌÑ∞ ÏÑ†ÌÉù</button>
            </div>
        </div>
    </div>

    <div class="game-container">
        <h1>üå± ÎèÑÌä∏ Í≤åÏûÑ üå±</h1>
        <div class="top-ui">
            <div class="score-display">
                <div class="score-row"><span class="score-label">ÌòÑÏû¨</span><span class="score-value" id="score">0</span></div>
                <div class="score-row"><span class="score-label">ÏßÄÎÇú</span><span class="score-value" id="previousScore">0</span></div>
            </div>
            <div class="health-bar-container">
                <div class="health-bar" id="healthBar"></div>
                <div class="health-bar-text">Ï≤¥Î†•: <span id="health">12</span> / 12</div>
            </div>
            <div class="weapon-display" id="weaponDisplay">‚öî Í≤Ä</div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div class="info">
            <div class="controls">Î∞©Ìñ•ÌÇ§: Ïù¥Îèô | Ïä§ÌéòÏù¥Ïä§Î∞î: Í≥µÍ≤©</div>
        </div>
    </div>

    <!-- Î™®Î∞îÏùº Ïª®Ìä∏Î°§ -->
    <div class="mobile-controls">
        <div class="joystick-container">
            <div class="joystick-base" id="joystickBase">
                <div class="joystick-stick" id="joystickStick"></div>
            </div>
        </div>
        <div class="attack-button" id="attackButton">‚öî</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 32;
        const ATTACK_ANIMATION_MAX = 18;

        const characterSelect = document.getElementById('characterSelect');
        const characterOptions = document.querySelectorAll('.character-option');
        
        function drawCharacterSample(canvas, shape, colorData) {
            const ctx = canvas.getContext('2d');
            const size = canvas.width;
            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size * 0.35;
            
            ctx.clearRect(0, 0, size, size);
            
            if (shape === 'square') {
                const halfSize = radius;
                ctx.fillStyle = colorData.bodyColor;
                ctx.fillRect(centerX - halfSize, centerY - halfSize, halfSize * 2, halfSize * 2);
                ctx.strokeStyle = colorData.outlineColor;
                ctx.lineWidth = 4;
                ctx.strokeRect(centerX - halfSize, centerY - halfSize, halfSize * 2, halfSize * 2);
                
                ctx.fillStyle = colorData.accentColor;
                ctx.fillRect(centerX - halfSize * 0.6, centerY - halfSize * 0.6, halfSize * 1.2, halfSize * 1.2);
            } else if (shape === 'circle') {
                ctx.fillStyle = colorData.bodyColor;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = colorData.outlineColor;
                ctx.lineWidth = 4;
                ctx.stroke();
                
                ctx.fillStyle = colorData.accentColor;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius * 0.7, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape === 'star') {
                const starPoints = 5;
                const outerRadius = radius;
                const innerRadius = radius * 0.4;
                ctx.fillStyle = colorData.bodyColor;
                ctx.beginPath();
                for (let i = 0; i < starPoints * 2; i++) {
                    const angle = (i * Math.PI) / starPoints - Math.PI / 2;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = colorData.outlineColor;
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }
        

        const scoreValueEl = document.getElementById('score');
        const previousScoreEl = document.getElementById('previousScore');
        const healthValueEl = document.getElementById('health');
        const healthBarEl = document.getElementById('healthBar');
        const weaponDisplayEl = document.getElementById('weaponDisplay');

        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverPreviousScoreEl = document.getElementById('gameOverPreviousScore');
        const restartButton = document.getElementById('restartButton');
        const changeCharacterButton = document.getElementById('changeCharacterButton');

        const joystickBase = document.getElementById('joystickBase');
        const joystickStick = document.getElementById('joystickStick');
        const attackButton = document.getElementById('attackButton');

        function setCharacterOptionsTabIndex(value) {
            characterOptions.forEach(opt => opt.setAttribute('tabindex', value));
        }

        const characters = {
            blue: {
                bodyColor: '#4aa3ff',
                accentColor: '#7ec8ff',
                outlineColor: '#0b3d91',
                detailColor: '#f5fbff',
                auraColor: '#1f6feb',
                shape: 'square',
                health: 12,
                speedMultiplier: 1.0,
                weaponNames: ['‚öî Í≤Ä', '‚öî‚öî ÏåçÍ≤Ä', 'üó° ÎåÄÍ≤Ä']
            },
            violet: {
                bodyColor: '#b06cff',
                accentColor: '#d9a7ff',
                outlineColor: '#431d77',
                detailColor: '#f8ecff',
                auraColor: '#8f4dff',
                shape: 'circle',
                health: 10,
                speedMultiplier: 0.8,
                weaponNames: ['üèπ Ìôú', 'üî´ Í∂åÏ¥ù', 'üí• ÏÉ∑Í±¥']
            },
            pink: {
                bodyColor: '#ff69b4',
                accentColor: '#ffb3d9',
                outlineColor: '#8b2252',
                detailColor: '#fff0f8',
                auraColor: '#ff1493',
                shape: 'star',
                health: 8,
                speedMultiplier: 0.65,
                weaponNames: ['‚ú® Îß§ÏßÅÎØ∏ÏÇ¨Ïùº', 'üî• ÌååÏù¥Ïñ¥Î≥º', '‚òÑ Î©îÌÖåÏò§']
            }
        };

        characterOptions.forEach(option => {
            const canvas = option.querySelector('.character-sample');
            const shape = canvas.getAttribute('data-shape');
            const charKey = option.getAttribute('data-character');
            const charData = characters[charKey];
            if (canvas && charData) {
                drawCharacterSample(canvas, shape, charData);
            }
        });



        const monsterPalettes = [
            { base: '#ff6b6b', secondary: '#c0392b', outline: '#641e16', eye: '#ffeaa7', tooth: '#f7f1e3' },
            { base: '#ff8c42', secondary: '#ff5e57', outline: '#7f1d1d', eye: '#fff3b0', tooth: '#ffe8d6' },
            { base: '#f53b57', secondary: '#833471', outline: '#3d0c41', eye: '#fbf1f2', tooth: '#f8edeb' }
        ];

        const yellowPalette = { base: '#f1c40f', secondary: '#f9e79f', outline: '#b9770e', eye: '#2c3e50', tooth: '#fff9db' };

        let backgroundTiles = [];
        let backgroundGrid = [];
        let backgroundCols = 0;
        let backgroundRows = 0;

        const game = {
            score: 0,
            previousScore: 0,
            health: 12,
            maxHealth: 12,
            keys: {},
            touchDirection: { x: 0, y: 0 }
        };

        const weaponProfiles = {
            blue: [
                { rangeMin: 20, rangeMax: 64, width: 16, speed: 1.0 },
                { rangeMin: 20, rangeMax: 64, width: 20, speed: 0.8 },
                { rangeMin: 25, rangeMax: 96, width: 24, speed: 0.6 }
            ],
            violet: [
                { rangeMin: 30, rangeMax: 64, width: 8, speed: 0.5 },
                { rangeMin: 40, rangeMax: 96, width: 6, speed: 0.6 },
                { rangeMin: 30, rangeMax: 96, width: 12, speed: 1.0 }
            ],
            pink: [
                { rangeMin: 30, rangeMax: 64, width: 10, speed: 0.7 },
                { rangeMin: 40, rangeMax: 96, width: 14, speed: 0.6 },
                { rangeMin: 50, rangeMax: 64, width: 18, speed: 0.5, splash: true }
            ]
        };

        const baseSpeed = 3.1;
        const player = {
            x: 400,
            y: 300,
            size: 28,
            speed: baseSpeed,
            attackAnimation: 0,
            attackCooldown: 0,
            weaponLevel: 1,
            attackDirection: { x: 1, y: 0 },
            bodyColor: characters.blue.bodyColor,
            accentColor: characters.blue.accentColor,
            outlineColor: characters.blue.outlineColor,
            detailColor: characters.blue.detailColor,
            auraColor: characters.blue.auraColor,
            shape: 'square',
            characterType: 'blue',
            invincible: false,
            invincibleTimer: 0
        };
        player.color = player.bodyColor;

        const monsters = [];
        let monsterSpawnTimer = 0;
        let monsterSpawnInterval = 120;
        let yellowMonsterTimer = 0;
        const yellowMonsterInterval = 600;
        const missiles = [];
        let missileTimer = 0;
        const missileSpawnInterval = 600;

        let gameStarted = false;
        let maxMonstersAllowed = 5;
        const maxMonstersCap = 20;
        let difficultyTimer = 0;
        const difficultyIncreaseInterval = 600;
        let gameOverPending = false;

        function resizeCanvas() {
            const maxWidth = Math.min(800, window.innerWidth - 40);
            const maxHeight = Math.min(600, window.innerHeight - 200);
            
            const aspectRatio = 800 / 600;
            let width = maxWidth;
            let height = width / aspectRatio;
            
            if (height > maxHeight) {
                height = maxHeight;
                width = height * aspectRatio;
            }
            
            canvas.width = 800;
            canvas.height = 600;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function applyCharacterStyle(key) {
            const style = characters[key] || characters.blue;
            player.bodyColor = style.bodyColor;
            player.accentColor = style.accentColor;
            player.outlineColor = style.outlineColor;
            player.detailColor = style.detailColor;
            player.auraColor = style.auraColor;
            player.color = style.bodyColor;
            player.shape = style.shape;
            player.speed = baseSpeed * style.speedMultiplier;
            player.characterType = key;
            game.maxHealth = style.health;
            game.health = style.health;
            updateHealth();
        }

        function handleCharacterSelect(option) {
            const key = option.dataset.character;
            characterOptions.forEach(opt => opt.classList.remove('selected'));
            option.classList.add('selected');
            applyCharacterStyle(key);
            characterSelect.classList.remove('show');
            characterSelect.setAttribute('aria-hidden', 'true');
            if (!gameStarted) {
                gameStarted = true;
            }
            resetGame();
            setCharacterOptionsTabIndex('-1');
            if (document.activeElement === option) {
                option.blur();
            }
        }

        characterOptions.forEach(option => {
            option.setAttribute('tabindex', '0');
            option.addEventListener('click', () => handleCharacterSelect(option));
            option.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    handleCharacterSelect(option);
                }
            });
        });

        function initBackground() {
            backgroundTiles = [];
            backgroundGrid = [];
            backgroundCols = Math.ceil(800 / tileSize);
            backgroundRows = Math.ceil(600 / tileSize);

            for (let row = 0; row < backgroundRows; row++) {
                const rowTiles = [];
                for (let col = 0; col < backgroundCols; col++) {
                    // Í∞ÄÏû•ÏûêÎ¶¨ ÌÉÄÏùºÏóêÎäî Ïû•Ïï†Î¨º ÏÉùÏÑ± Ïïà Ìï®
                    const isEdge = row === 0 || row === backgroundRows - 1 || col === 0 || col === backgroundCols - 1;
                    
                    const random = Math.random();
                    let overlay = null;
                    let obstacle = false;

                    if (!isEdge) {
                        if (random < 0.06) {
                            overlay = 'tree';
                            obstacle = true;
                        } else if (random < 0.11) {
                            overlay = 'rock';
                            obstacle = true;
                        }
                    }

                    const tile = {
                        x: col * tileSize,
                        y: row * tileSize,
                        lightness: 28 + Math.floor(Math.random() * 10),
                        textureVariant: Math.random(),
                        overlay,
                        obstacle,
                        variant: Math.random()
                    };

                    backgroundTiles.push(tile);
                    rowTiles.push(tile);
                }
                backgroundGrid.push(rowTiles);
            }
        }

        function drawOverlay(tile) {
            const centerX = tile.x + tileSize / 2;
            const centerY = tile.y + tileSize / 2;
            ctx.save();
            ctx.translate(centerX, centerY);

            switch (tile.overlay) {
                case 'tree': {
                    ctx.fillStyle = '#6b3f1f';
                    ctx.fillRect(-4, 6, 8, 12);
                    const gradient = ctx.createRadialGradient(0, -6, 4, 0, -6, 16);
                    gradient.addColorStop(0, '#41d77a');
                    gradient.addColorStop(1, '#1f8f4f');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.ellipse(0, -6, 12, 14, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                }
                case 'rock': {
                    ctx.fillStyle = '#d0d6d8';
                    ctx.beginPath();
                    ctx.moveTo(-10, 8);
                    ctx.lineTo(0, -10);
                    ctx.lineTo(12, 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(66, 73, 80, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255,255,255,0.35)';
                    ctx.beginPath();
                    ctx.moveTo(-2, -2);
                    ctx.lineTo(4, -6);
                    ctx.lineTo(6, 2);
                    ctx.closePath();
                    ctx.fill();
                    break;
                }
            }
            ctx.restore();
        }

        function drawBackground() {
            backgroundTiles.forEach(tile => {
                ctx.fillStyle = `hsl(140, 45%, ${tile.lightness}%)`;
                ctx.fillRect(tile.x, tile.y, tileSize, tileSize);

                ctx.fillStyle = `rgba(255, 255, 255, ${0.035 + tile.textureVariant * 0.025})`;
                ctx.fillRect(tile.x + (tile.textureVariant * tileSize) % tileSize, tile.y + (tile.textureVariant * 7) % tileSize, 1.2, 1.2);

                ctx.fillStyle = `rgba(0, 0, 0, ${0.04 * tile.textureVariant})`;
                ctx.fillRect(tile.x + ((1 - tile.textureVariant) * tileSize) % tileSize, tile.y + ((tile.textureVariant * 5) % tileSize), 1, 1);
            });

            backgroundTiles.forEach(tile => {
                if (tile.overlay) {
                    drawOverlay(tile);
                }
            });
        }

        function checkCollision(x, y, size) {
            const half = size / 2;
            const left = x - half;
            const right = x + half;
            const top = y - half;
            const bottom = y + half;

            const startCol = Math.floor(left / tileSize);
            const endCol = Math.floor(right / tileSize);
            const startRow = Math.floor(top / tileSize);
            const endRow = Math.floor(bottom / tileSize);
            
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    if (row < 0 || col < 0 || row >= backgroundRows || col >= backgroundCols) continue;
                    const tile = backgroundGrid[row][col];
                    if (tile && tile.obstacle) {
                        const tileLeft = tile.x;
                        const tileRight = tile.x + tileSize;
                        const tileTop = tile.y;
                        const tileBottom = tile.y + tileSize;
                        if (right > tileLeft && left < tileRight && bottom > tileTop && top < tileBottom) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function drawWeaponEffect() {
            const angle = Math.atan2(player.attackDirection.y || 0, player.attackDirection.x || 1);
            const charType = player.characterType;
            const profiles = weaponProfiles[charType];
            const profile = profiles[player.weaponLevel - 1];
            const animProgress = player.attackAnimation / ATTACK_ANIMATION_MAX;
            const speedModifier = profile.speed || 0.5;
            const effectiveProgress = Math.min(1.0, animProgress * speedModifier);

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(angle);

            if (charType === 'blue') {
                if (player.weaponLevel === 1) {
                    const swingAngle = (1 - effectiveProgress) * Math.PI * 0.6 - Math.PI * 0.3;
                    const swordLength = profile.rangeMax * effectiveProgress;
                    const tipX = Math.cos(swingAngle) * swordLength;
                    const tipY = Math.sin(swingAngle) * swordLength;
                    
                    const gradient = ctx.createLinearGradient(0, 0, tipX, tipY);
                    gradient.addColorStop(0, 'rgba(74, 163, 255, 1.0)');
                    gradient.addColorStop(0.5, 'rgba(126, 200, 255, 0.95)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 7;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(74, 163, 255, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(tipX, tipY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.fillRect(tipX - 8, tipY - 4, 16, 8);
                    
                    for (let trail = 0; trail < 3; trail++) {
                        const trailProgress = effectiveProgress - trail * 0.1;
                        if (trailProgress > 0) {
                            const trailLength = swordLength * trailProgress * 0.8;
                            const trailX = Math.cos(swingAngle) * trailLength;
                            const trailY = Math.sin(swingAngle) * trailLength;
                            ctx.strokeStyle = `rgba(74, 163, 255, ${0.3 * (1 - trail * 0.3)})`;
                            ctx.lineWidth = 3 - trail;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(trailX, trailY);
                            ctx.stroke();
                        }
                    }
                } else if (player.weaponLevel === 2) {
                    const swingAngle = (1 - effectiveProgress) * Math.PI * 0.6 - Math.PI * 0.3;
                    const swordLength = profile.rangeMax * effectiveProgress;
                    
                    for (let i = 0; i < 2; i++) {
                        const offset = (i - 0.5) * 0.15;
                        const swordAngle = swingAngle + offset;
                        const tipX = Math.cos(swordAngle) * swordLength;
                        const tipY = Math.sin(swordAngle) * swordLength;
                        
                        const gradient = ctx.createLinearGradient(0, 0, tipX, tipY);
                        gradient.addColorStop(0, 'rgba(74, 163, 255, 1.0)');
                        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.95)');
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = 6;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = 'rgba(74, 163, 255, 0.7)';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(tipX, tipY);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                        ctx.fillRect(tipX - 7, tipY - 4, 14, 8);
                    }
                } else {
                    const swingAngle = (1 - effectiveProgress) * Math.PI * 0.5 - Math.PI * 0.25;
                    const swordLength = profile.rangeMax * effectiveProgress;
                    const tipX = Math.cos(swingAngle) * swordLength;
                    const tipY = Math.sin(swingAngle) * swordLength;
                    
                    const gradient = ctx.createLinearGradient(0, 0, tipX, tipY);
                    gradient.addColorStop(0, 'rgba(74, 163, 255, 1.0)');
                    gradient.addColorStop(0.3, 'rgba(126, 200, 255, 0.98)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 1.0)');
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = 12;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(74, 163, 255, 0.9)';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(tipX, tipY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.fillRect(tipX - 14, tipY - 7, 28, 14);
                    
                    ctx.fillStyle = 'rgba(200, 220, 255, 0.9)';
                    ctx.fillRect(tipX - 16, tipY - 6, 32, 12);
                    
                    for (let spark = 0; spark < 5; spark++) {
                        const sparkAngle = swingAngle + (spark - 2) * 0.1;
                        const sparkDist = swordLength * 0.7;
                        const sparkX = Math.cos(sparkAngle) * sparkDist;
                        const sparkY = Math.sin(sparkAngle) * sparkDist;
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                }
            } else if (charType === 'violet') {
                if (player.weaponLevel === 1) {
                    const arrowDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                    const arrowX = arrowDist;
                    const arrowY = 0;
                    
                    ctx.strokeStyle = 'rgba(176, 108, 255, 1.0)';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = 'rgba(176, 108, 255, 0.8)';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(arrowX, arrowY);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(139, 69, 19, 1.0)';
                    ctx.beginPath();
                    ctx.moveTo(arrowX, arrowY);
                    ctx.lineTo(arrowX + 10, arrowY - 4);
                    ctx.lineTo(arrowX + 10, arrowY + 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.beginPath();
                    ctx.arc(arrowX + 7, arrowY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    for (let trail = 0; trail < 2; trail++) {
                        const trailX = arrowX - trail * 15;
                        if (trailX > 0) {
                            ctx.strokeStyle = `rgba(176, 108, 255, ${0.4 * (1 - trail * 0.5)})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(trailX, arrowY - 2);
                            ctx.lineTo(trailX, arrowY + 2);
                            ctx.stroke();
                        }
                    }
                } else if (player.weaponLevel === 2) {
                    const bulletDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                    const bulletX = bulletDist;
                    const bulletY = 0;
                    
                    const gradient = ctx.createRadialGradient(bulletX, bulletY, 0, bulletX, bulletY, 8);
                    gradient.addColorStop(0, 'rgba(176, 108, 255, 1.0)');
                    gradient.addColorStop(0.5, 'rgba(217, 167, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(176, 108, 255, 0.6)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = 'rgba(176, 108, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(bulletX, bulletY, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.beginPath();
                    ctx.arc(bulletX, bulletY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(139, 0, 139, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(bulletX, bulletY);
                    ctx.stroke();
                } else {
                    for (let i = 0; i < 3; i++) {
                        const spread = (i - 1) * 0.2;
                        const shotAngle = spread;
                        const bulletDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                        const bulletX = Math.cos(shotAngle) * bulletDist;
                        const bulletY = Math.sin(shotAngle) * bulletDist;
                        
                        const gradient = ctx.createRadialGradient(bulletX, bulletY, 0, bulletX, bulletY, 9);
                        gradient.addColorStop(0, 'rgba(176, 108, 255, 1.0)');
                        gradient.addColorStop(1, 'rgba(143, 77, 255, 0.7)');
                        
                        ctx.fillStyle = gradient;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = 'rgba(176, 108, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(bulletX, bulletY, 9, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                        ctx.beginPath();
                        ctx.arc(bulletX, bulletY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            } else {
                if (player.weaponLevel === 1) {
                    const missileDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                    const missileX = missileDist;
                    const missileY = 0;
                    
                    const gradient = ctx.createRadialGradient(missileX, missileY, 0, missileX, missileY, 12);
                    gradient.addColorStop(0, 'rgba(70, 130, 180, 1.0)');
                    gradient.addColorStop(0.5, 'rgba(135, 206, 250, 0.9)');
                    gradient.addColorStop(1, 'rgba(70, 130, 180, 0.6)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(70, 130, 180, 0.8)';
                    ctx.beginPath();
                    ctx.arc(missileX, missileY, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(135, 206, 250, 1.0)';
                    ctx.beginPath();
                    ctx.arc(missileX, missileY, 7, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 1.0)';
                    ctx.beginPath();
                    ctx.arc(missileX, missileY, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.strokeStyle = 'rgba(70, 130, 180, 0.7)';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(missileX, missileY);
                            ctx.stroke();
                } else if (player.weaponLevel === 2) {
                    const fireDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                    const fireX = fireDist;
                    const fireY = 0;
                    const fireSize = 16 + Math.sin(effectiveProgress * Math.PI * 4) * 6;
                    
                    const gradient = ctx.createRadialGradient(fireX, fireY, 0, fireX, fireY, fireSize);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                    gradient.addColorStop(0.2, 'rgba(255, 215, 0, 1.0)');
                    gradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.95)');
                    gradient.addColorStop(1, 'rgba(255, 69, 0, 0.7)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 69, 0, 0.9)';
                            ctx.beginPath();
                    ctx.arc(fireX, fireY, fireSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(fireX, fireY, fireSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    for (let spark = 0; spark < 6; spark++) {
                        const sparkAngle = (spark * Math.PI * 2 / 6) + effectiveProgress * Math.PI * 4;
                        const sparkDist = fireSize * 0.8;
                        const sparkX = fireX + Math.cos(sparkAngle) * sparkDist;
                        const sparkY = fireY + Math.sin(sparkAngle) * sparkDist;
                        ctx.fillStyle = 'rgba(255, 255, 200, 0.9)';
                        ctx.beginPath();
                        ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                } else {
                    const meteorDist = profile.rangeMin + (profile.rangeMax - profile.rangeMin) * effectiveProgress;
                    const meteorX = meteorDist;
                    const meteorY = 0;
                    const meteorSize = 10;
                    
                    ctx.fillStyle = 'rgba(70, 130, 180, 0.9)';
                    ctx.beginPath();
                    ctx.arc(meteorX, meteorY, meteorSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(135, 206, 250, 0.8)';
                        ctx.beginPath();
                    ctx.arc(meteorX, meteorY, meteorSize * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.beginPath();
                    ctx.arc(meteorX, meteorY, meteorSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (effectiveProgress >= 0.7) {
                        const splashRadius = 35;
                        const perpAngle = Math.PI / 2;
                        for (let side = -1; side <= 1; side += 2) {
                            const splashProgress = Math.min(1.0, (effectiveProgress - 0.7) / 0.3);
                            const splashX = meteorX + Math.cos(perpAngle) * side * splashRadius * splashProgress;
                            const splashY = meteorY + Math.sin(perpAngle) * side * splashRadius * splashProgress;
                            const splashSize = 16 + 8 * splashProgress;
                            
                            const gradient = ctx.createRadialGradient(splashX, splashY, 0, splashX, splashY, splashSize);
                            gradient.addColorStop(0, `rgba(255, 69, 0, ${0.9 * splashProgress})`);
                            gradient.addColorStop(0.5, `rgba(255, 140, 0, ${0.7 * splashProgress})`);
                            gradient.addColorStop(1, `rgba(255, 200, 0, ${0.3 * splashProgress})`);
                            
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(splashX, splashY, splashSize, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * splashProgress})`;
                            ctx.beginPath();
                            ctx.arc(splashX, splashY, splashSize * 0.4, 0, Math.PI * 2);
                            ctx.fill();
                            
                            for (let spark = 0; spark < 3; spark++) {
                                const sparkAngle = (spark * Math.PI * 2 / 3) + effectiveProgress * Math.PI * 2;
                                const sparkDist = splashSize * 0.7;
                                const sparkX = splashX + Math.cos(sparkAngle) * sparkDist;
                                const sparkY = splashY + Math.sin(sparkAngle) * sparkDist;
                                ctx.fillStyle = `rgba(255, 255, 200, ${0.8 * splashProgress})`;
                                ctx.beginPath();
                                ctx.arc(sparkX, sparkY, 3, 0, Math.PI * 2);
                        ctx.fill();
                            }
                        }
                    }
                }
            }

            ctx.restore();
        }

        function drawPlayer() {
            if (player.attackAnimation > 0) {
                drawWeaponEffect();
            }

            ctx.save();
            ctx.translate(player.x, player.y);
            
            // Î¨¥Ï†Å ÏÉÅÌÉúÏùº Îïå Î∞òÌà¨Î™Ö Ìö®Í≥º
            if (player.invincible) {
                const alpha = 0.3 + Math.sin(Date.now() / 50) * 0.2;
                ctx.globalAlpha = Math.max(0.3, Math.min(0.7, alpha));
            }

            const radius = player.size / 2;
            const halfSize = radius;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            if (player.shape === 'square') {
                ctx.fillRect(-halfSize * 1.2, halfSize * 0.8, halfSize * 2.4, halfSize * 0.6);
            } else if (player.shape === 'circle') {
                ctx.beginPath();
                ctx.ellipse(0, player.size / 2, player.size / 1.8, player.size / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.ellipse(0, player.size / 2, player.size / 1.8, player.size / 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            const gradient = ctx.createLinearGradient(-halfSize, -halfSize, halfSize, halfSize);
            gradient.addColorStop(0, player.accentColor);
            gradient.addColorStop(1, player.bodyColor);
            ctx.fillStyle = gradient;

            if (player.shape === 'square') {
                ctx.fillRect(-halfSize, -halfSize, player.size, player.size);
                    ctx.lineWidth = 4;
                ctx.strokeStyle = player.outlineColor;
                ctx.strokeRect(-halfSize, -halfSize, player.size, player.size);

                ctx.fillStyle = player.detailColor;
                ctx.fillRect(-halfSize * 0.4, -halfSize * 0.6, halfSize * 0.25, halfSize * 0.25);
                ctx.fillRect(halfSize * 0.15, -halfSize * 0.6, halfSize * 0.25, halfSize * 0.25);

                ctx.fillStyle = '#1f2933';
                ctx.fillRect(-halfSize * 0.35, -halfSize * 0.55, halfSize * 0.15, halfSize * 0.15);
                ctx.fillRect(halfSize * 0.2, -halfSize * 0.55, halfSize * 0.15, halfSize * 0.15);

                ctx.strokeStyle = player.detailColor;
                ctx.lineWidth = 2;
                    ctx.beginPath();
                ctx.moveTo(-halfSize * 0.3, halfSize * 0.3);
                ctx.lineTo(-halfSize * 0.1, halfSize * 0.4);
                ctx.lineTo(halfSize * 0.1, halfSize * 0.4);
                ctx.lineTo(halfSize * 0.3, halfSize * 0.3);
                    ctx.stroke();
            } else if (player.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.lineWidth = 4;
                ctx.strokeStyle = player.outlineColor;
                ctx.stroke();

                ctx.fillStyle = player.detailColor;
                ctx.beginPath();
                ctx.arc(-radius / 3, -radius / 5, radius / 5, 0, Math.PI * 2);
                ctx.arc(radius / 3, -radius / 5, radius / 5, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#1f2933';
                ctx.beginPath();
                ctx.arc(-radius / 3, -radius / 5, radius / 8, 0, Math.PI * 2);
                ctx.arc(radius / 3, -radius / 5, radius / 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = player.detailColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, radius / 6, radius / 3, 0, Math.PI);
                ctx.stroke();
            } else {
                const starPoints = 5;
                const outerRadius = radius;
                const innerRadius = radius * 0.4;
                ctx.beginPath();
                for (let i = 0; i < starPoints * 2; i++) {
                    const angle = (i * Math.PI) / starPoints - Math.PI / 2;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();

                ctx.lineWidth = 4;
                ctx.strokeStyle = player.outlineColor;
                ctx.stroke();

                ctx.fillStyle = player.detailColor;
                ctx.beginPath();
                ctx.arc(-radius * 0.25, -radius * 0.3, radius * 0.15, 0, Math.PI * 2);
                ctx.arc(radius * 0.25, -radius * 0.3, radius * 0.15, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#1f2933';
                ctx.beginPath();
                ctx.arc(-radius * 0.25, -radius * 0.3, radius * 0.08, 0, Math.PI * 2);
                ctx.arc(radius * 0.25, -radius * 0.3, radius * 0.08, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = player.detailColor;
                ctx.beginPath();
                ctx.arc(0, radius * 0.2, radius * 0.12, 0, Math.PI);
                ctx.fill();
            }

            ctx.strokeStyle = player.auraColor;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([3, 4]);
            if (player.shape === 'square') {
                ctx.strokeRect(-halfSize - 4, -halfSize - 4, player.size + 8, player.size + 8);
            } else if (player.shape === 'circle') {
                ctx.beginPath();
                ctx.arc(0, 0, radius + 4, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, radius + 4, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // Î¨¥Ï†Å ÏÉÅÌÉúÏùº Îïå globalAlpha Î≥µÏõê
            if (player.invincible) {
                ctx.globalAlpha = 1.0;
            }

            ctx.restore();
        }

					function spawnMonster(isYellow = false) {
 						 if (monsters.length >= maxMonstersAllowed) return;

					  const trySpawn = () => {
					    const side = Math.floor(Math.random() * 4);
					    let x, y;
					    switch (side) {
					      case 0: x = Math.random() * canvas.width; y = -30; break;
					      case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
					      case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
					      default: x = -30; y = Math.random() * canvas.height; break;
					    }
					    return { x, y };
					  };
					
					  // üî∏ ÏµúÎåÄ 20Î≤àÍπåÏßÄ ÏïàÏ†Ñ Ï¢åÌëú ÌÉêÏÉâ
					  let pos = trySpawn();
					  let tries = 0;
					  while (tries < 20 && checkCollision(pos.x, pos.y, isYellow ? 26 : 24)) { // ‚Üê ÌòÑÏû¨ checkCollision Ïû¨ÏÇ¨Ïö©
					    pos = trySpawn();
					    tries++;
					  }
					
					  const palette = isYellow ? yellowPalette : monsterPalettes[Math.floor(Math.random() * monsterPalettes.length)];
					  const size = isYellow ? 26 : 24;
					  const speed = isYellow ? 0.9 + Math.random() * 1.1 : 1.2 + Math.random() * 1.3;
					
					  monsters.push({
					    x: pos.x,
					    y: pos.y,
					    size,
					    speed,
					    palette,
					    attackAnimation: 0,
					    lastDamageTime: 0,
					    isYellow,
					    wobbleSeed: Math.random(),
					    variant: Math.floor(Math.random() * 3),
					    // ‚¨áÔ∏è ÏñºÎ¨∂ÏûÑ Í∞êÏßÄÏö©
					    _lastX: pos.x, _lastY: pos.y, _stuckFrames: 0
					  });
					}


        function drawMonsters() {
            const now = Date.now();
            monsters.forEach(monster => {
                    const dx = player.x - monster.x;
                    const dy = player.y - monster.y;
                const dist = Math.sqrt(dx * dx + dy * dy) || 1;

                ctx.save();
                ctx.translate(monster.x, monster.y);

                if (monster.attackAnimation > 0) {
                    const reach = 18 + monster.attackAnimation * 1.5;
                    ctx.fillStyle = 'rgba(192, 57, 43, 0.35)';
                    ctx.beginPath();
                    ctx.arc((dx / dist) * reach, (dy / dist) * reach, 12, 0, Math.PI * 2);
                    ctx.fill();
                }

                const pulse = Math.sin(now / 200 + monster.wobbleSeed * Math.PI) * 0.08 + 1;
                const radius = (monster.size / 2) * pulse;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.beginPath();
                ctx.ellipse(0, radius + 6, radius * 1.3, radius / 2.3, 0, 0, Math.PI * 2);
                ctx.fill();

                const gradient = ctx.createRadialGradient(-radius / 3, -radius / 3, radius / 4, 0, 0, radius);
                gradient.addColorStop(0, monster.palette.secondary);
                gradient.addColorStop(1, monster.palette.base);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.lineWidth = 3;
                ctx.strokeStyle = monster.palette.outline;
                ctx.stroke();

                ctx.fillStyle = monster.palette.outline;
                if (!monster.isYellow) {
                    if (monster.variant === 0) {
                        ctx.beginPath();
                        ctx.moveTo(-radius + 4, -radius + 2);
                        ctx.lineTo(-radius - 6, -radius - 10);
                        ctx.lineTo(-radius + 6, -radius + 4);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(radius - 4, -radius + 2);
                        ctx.lineTo(radius + 6, -radius - 10);
                        ctx.lineTo(radius - 6, -radius + 4);
                        ctx.fill();
                    } else if (monster.variant === 1) {
                        ctx.beginPath();
                        ctx.moveTo(0, -radius - 8);
                        ctx.lineTo(-6, -radius + 4);
                        ctx.lineTo(6, -radius + 4);
                        ctx.fill();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(-radius + 2, radius - 4);
                        ctx.lineTo(-radius - 6, radius + 6);
                        ctx.lineTo(-radius + 6, radius - 2);
                        ctx.fill();

                        ctx.beginPath();
                        ctx.moveTo(radius - 2, radius - 4);
                        ctx.lineTo(radius + 6, radius + 6);
                        ctx.lineTo(radius - 6, radius - 2);
                        ctx.fill();
                    }
                }

                ctx.fillStyle = monster.palette.eye;
                if (monster.variant === 1 && !monster.isYellow) {
                    ctx.beginPath();
                    ctx.arc(0, -radius / 6, radius / 4 + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = monster.isYellow ? '#2c3e50' : '#111';
                    ctx.beginPath();
                    ctx.arc(0, -radius / 6, radius / 7, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(-radius / 3, -radius / 5, radius / 5, 0, Math.PI * 2);
                    ctx.arc(radius / 3, -radius / 5, radius / 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = monster.isYellow ? '#2c3e50' : '#111';
                    ctx.beginPath();
                    ctx.arc(-radius / 3, -radius / 5, radius / 7, 0, Math.PI * 2);
                    ctx.arc(radius / 3, -radius / 5, radius / 7, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.strokeStyle = monster.palette.outline;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, radius / 3, radius / 2.2, 0, Math.PI);
                ctx.stroke();

                ctx.fillStyle = monster.palette.tooth;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * 4, radius / 3);
                    ctx.lineTo(i * 4 + 2, radius / 2.2);
                    ctx.lineTo(i * 4 + 4, radius / 3);
                    ctx.closePath();
                    ctx.fill();
                }

                if (monster.isYellow) {
                    const aura = Math.sin(now / 250 + monster.wobbleSeed) * 0.2 + 1.2;
                    ctx.strokeStyle = `rgba(241, 196, 15, ${0.4 * aura})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, radius + 6, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            });
        }

        function spawnMissile() {
            const size = 24;
            const speed = 4 + Math.random() * 1.8;
            const side = Math.floor(Math.random() * 4);
            let x;
            let y;

            switch (side) {
                case 0:
                    x = Math.random() * canvas.width;
                    y = -40;
                    break;
                case 1:
                    x = canvas.width + 40;
                    y = Math.random() * canvas.height;
                    break;
                case 2:
                    x = Math.random() * canvas.width;
                    y = canvas.height + 40;
                    break;
                default:
                    x = -40;
                    y = Math.random() * canvas.height;
                    break;
            }

            const targetX = Math.random() * canvas.width;
            const targetY = Math.random() * canvas.height;
            const dx = targetX - x;
            const dy = targetY - y;
            const dist = Math.hypot(dx, dy) || 1;

            const vx = (dx / dist) * speed;
            const vy = (dy / dist) * speed;

            missiles.push({
                x,
                y,
                vx,
                vy,
                size,
                damage: 2,
                rotation: Math.atan2(vy, vx)
            });
        }

        function updateMissiles() {
            for (let i = missiles.length - 1; i >= 0; i--) {
                const missile = missiles[i];
                missile.x += missile.vx;
                missile.y += missile.vy;
                missile.rotation = Math.atan2(missile.vy, missile.vx);

                if (missile.x < -80 || missile.x > canvas.width + 80 || missile.y < -80 || missile.y > canvas.height + 80) {
                    missiles.splice(i, 1);
                    continue;
                }

                if (!gameOverPending && !player.invincible) {
                    const distance = Math.hypot(player.x - missile.x, player.y - missile.y);
                    if (distance < missile.size / 2 + player.size / 2 - 2) {
                        missiles.splice(i, 1);
                        game.health = Math.max(0, game.health - missile.damage);
                        // Î¨¥Ï†Å ÏÉÅÌÉú Î∂ÄÏó¨ (1Ï¥à = 60ÌîÑÎ†àÏûÑ)
                        player.invincible = true;
                        player.invincibleTimer = 60;
                        updateHealth();
                        continue;
                    }
                }
            }
        }

        function drawMissiles() {
            missiles.forEach(missile => {
                ctx.save();
                ctx.translate(missile.x, missile.y);
                ctx.rotate(missile.rotation);

                const flameGradient = ctx.createLinearGradient(-missile.size, 0, 0, 0);
                flameGradient.addColorStop(0, 'rgba(255, 149, 0, 0)');
                flameGradient.addColorStop(1, 'rgba(255, 94, 0, 0.8)');
                ctx.fillStyle = flameGradient;
                ctx.beginPath();
                ctx.moveTo(-missile.size, 0);
                ctx.lineTo(-missile.size / 3, missile.size / 3);
                ctx.lineTo(-missile.size / 3, -missile.size / 3);
                ctx.closePath();
                ctx.fill();

                const bodyGradient = ctx.createLinearGradient(-missile.size / 2, 0, missile.size / 2, 0);
                bodyGradient.addColorStop(0, '#ff6b6b');
                bodyGradient.addColorStop(1, '#ff4757');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, missile.size / 2, missile.size / 3, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
                ctx.beginPath();
                ctx.arc(missile.size / 2 - 4, 0, 3.5, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();
            });
        }

        function findPathAroundObstacle(monster, targetX, targetY) {
            const dx = targetX - monster.x;
            const dy = targetY - monster.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1) return { x: monster.x, y: monster.y };
            
            const dirX = dx / dist;
            const dirY = dy / dist;
            const step = monster.speed;
            const newX = monster.x + dirX * step;
            const newY = monster.y + dirY * step;
            
            if (!checkCollision(newX, newY, monster.size)) {
                return { x: newX, y: newY };
            }
            
            const perpAngles = [Math.PI / 2, -Math.PI / 2, Math.PI / 4, -Math.PI / 4];
            for (const angle of perpAngles) {
                const perpX = Math.cos(angle);
                const perpY = Math.sin(angle);
                const testX = monster.x + (dirX * 0.5 + perpX * 0.5) * step;
                const testY = monster.y + (dirY * 0.5 + perpY * 0.5) * step;
                if (!checkCollision(testX, testY, monster.size)) {
                    return { x: testX, y: testY };
                }
            }
            
            if (!checkCollision(newX, monster.y, monster.size)) {
                return { x: newX, y: monster.y };
            }
            if (!checkCollision(monster.x, newY, monster.size)) {
                return { x: monster.x, y: newY };
            }
            
            return { x: monster.x, y: monster.y };
        }

        function updateMonsters() {
            const currentTime = Date.now();
            
            for (let i = monsters.length - 1; i >= 0; i--) {
                const monster = monsters[i];
                
                if (monster.attackAnimation > 0) {
                    monster.attackAnimation--;
                }
                
                const dx = player.x - monster.x;
                const dy = player.y - monster.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 1) {
                    const hasDirectLine = hasLineOfSight(monster.x, monster.y, player.x, player.y);
                    
                    if (hasDirectLine) {
                        const newPos = findPathAroundObstacle(monster, player.x, player.y);
                        monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, newPos.x));
                        monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, newPos.y));
                    } else {
                        // Ïû•Ïï†Î¨º Îí§Ïóê ÏûàÏñ¥ÎèÑ ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú Ïù¥Îèô ÏãúÎèÑ
                        const searchRadius = Math.min(canvas.width, canvas.height) * 0.3;
                        const searchSteps = 12;
                        let bestAngle = Math.atan2(dy, dx);
                        let bestDist = distance;
                        let foundPath = false;
                        
                        // ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú ÏßÅÏ†ë Ïù¥Îèô ÏãúÎèÑ
                        const directX = monster.x + Math.cos(bestAngle) * monster.speed;
                        const directY = monster.y + Math.sin(bestAngle) * monster.speed;
                        if (!checkCollision(directX, directY, monster.size)) {
                            monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, directX));
                            monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, directY));
                            foundPath = true;
                        }
                        
                        // ÏßÅÏ†ë Ïù¥ÎèôÏù¥ Ïïà ÎêòÎ©¥ Ï£ºÎ≥Ä ÌÉêÏÉâ
                        if (!foundPath) {
                            for (let s = 0; s < searchSteps; s++) {
                                const testAngle = bestAngle + (s - searchSteps / 2) * (Math.PI * 2 / searchSteps);
                                const testX = monster.x + Math.cos(testAngle) * monster.speed;
                                const testY = monster.y + Math.sin(testAngle) * monster.speed;
                                const testDist = Math.hypot(player.x - testX, player.y - testY);
                                
                                if (testDist < bestDist && !checkCollision(testX, testY, monster.size)) {
                                    bestAngle = testAngle;
                                    bestDist = testDist;
                                    foundPath = true;
                                }
                            }
                            
                            if (foundPath) {
                                const moveX = Math.cos(bestAngle) * monster.speed;
                                const moveY = Math.sin(bestAngle) * monster.speed;
                                const newX = monster.x + moveX;
                                const newY = monster.y + moveY;
                                
                                if (!checkCollision(newX, newY, monster.size)) {
                                    monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, newX));
                                    monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, newY));
                                } else if (!checkCollision(newX, monster.y, monster.size)) {
                                    monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, newX));
                                } else if (!checkCollision(monster.x, newY, monster.size)) {
                                    monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, newY));
                                }
                            } else {
                                // ÏôÑÏ†ÑÌûà ÎßâÌòÄÏûàÏñ¥ÎèÑ ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú ÏµúÎåÄÌïú Ïù¥Îèô ÏãúÎèÑ
                                const newPos = findPathAroundObstacle(monster, player.x, player.y);
                                monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, newPos.x));
                                monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, newPos.y));
                            }
                        }
                    }
                }

                const distToPlayer = Math.hypot(player.x - monster.x, player.y - monster.y);
                const attackRange = (player.size / 2) + (monster.size / 2) - 2;
                
                if (distToPlayer < attackRange) {
                    const safeDistance = Math.max(attackRange, 1);
                    const nx = distToPlayer > 0 ? (player.x - monster.x) / distToPlayer : 0;
                    const ny = distToPlayer > 0 ? (player.y - monster.y) / distToPlayer : 0;
                    const overlap = safeDistance - distToPlayer + 1.2;

                    if (overlap > 0) {
                        const pushDistance = tileSize * 1.0;
                        const monsterPush = pushDistance * 1.2;
                        const playerPush = pushDistance * 0.4;

                        const monsterTargetX = monster.x - nx * monsterPush;
                        const monsterTargetY = monster.y - ny * monsterPush;
                        if (!checkCollision(monsterTargetX, monster.y, monster.size)) {
                            monster.x = Math.max(monster.size / 2, Math.min(canvas.width - monster.size / 2, monsterTargetX));
                        }
                        if (!checkCollision(monster.x, monsterTargetY, monster.size)) {
                            monster.y = Math.max(monster.size / 2, Math.min(canvas.height - monster.size / 2, monsterTargetY));
                        }

                        const playerTargetX = player.x + nx * playerPush;
                        const playerTargetY = player.y + ny * playerPush;

                        if (!checkCollision(playerTargetX, player.y, player.size)) {
                            player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, playerTargetX));
                        }
                        if (!checkCollision(player.x, playerTargetY, player.size)) {
                            player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, playerTargetY));
                        }
                    }

                    if (currentTime - monster.lastDamageTime > 1000 && !gameOverPending && !player.invincible) {
                        monster.lastDamageTime = currentTime;
                        monster.attackAnimation = 10;
                        game.health -= 1;
                        if (player.weaponLevel > 1) {
                            player.weaponLevel -= 1;
                            updateWeaponDisplay();
                        }
                        // Î¨¥Ï†Å ÏÉÅÌÉú Î∂ÄÏó¨ (1Ï¥à = 60ÌîÑÎ†àÏûÑ)
                        player.invincible = true;
                        player.invincibleTimer = 60;
                        updateHealth();
                    }
                }
            }
        }

        function hasLineOfSight(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.hypot(dx, dy);
            const steps = Math.max(1, Math.ceil(distance / 8));
            for (let i = 1; i < steps; i++) {
                const t = i / steps;
                const sx = x1 + dx * t;
                const sy = y1 + dy * t;
                if (checkCollision(sx, sy, 6)) {
                    return false;
                }
            }
            return true;
        }

        function isMonsterHitByAttack(monster) {
            const charType = player.characterType;
            const profiles = weaponProfiles[charType];
            const profile = profiles[player.weaponLevel - 1];
            const dirX = player.attackDirection.x;
            const dirY = player.attackDirection.y;
            const relX = monster.x - player.x;
            const relY = monster.y - player.y;
            const forwardDist = relX * dirX + relY * dirY;
            
            if (forwardDist < profile.rangeMin || forwardDist > profile.rangeMax) {
                return false;
            }
            
            const sqDist = relX * relX + relY * relY;
            const perpendicularSq = Math.max(0, sqDist - forwardDist * forwardDist);
            
            if (charType === 'blue') {
                const swingAngle = Math.atan2(dirY, dirX);
                const monsterAngle = Math.atan2(relY, relX);
                let angleDiff = Math.abs(monsterAngle - swingAngle);
                if (angleDiff > Math.PI) angleDiff = Math.PI * 2 - angleDiff;
                
                if (player.weaponLevel === 1) {
                    if (angleDiff > Math.PI * 0.3) return false;
                } else if (player.weaponLevel === 2) {
                    if (angleDiff > Math.PI * 0.35) return false;
                } else {
                    if (angleDiff > Math.PI * 0.25) return false;
                }
            } else {
                if (perpendicularSq > profile.width * profile.width) {
                    return false;
                }
            }
            
            
            if (!hasLineOfSight(player.x, player.y, monster.x, monster.y)) {
                return false;
            }
            
            return true;
        }

        function upgradeWeapon() {
            if (player.weaponLevel < 3) {
                player.weaponLevel++;
                updateWeaponDisplay();
            }
        }

        function updateWeaponDisplay() {
            const charStyle = characters[player.characterType] || characters.blue;
            weaponDisplayEl.textContent = charStyle.weaponNames[player.weaponLevel - 1];
        }

        function updateScore() {
            scoreValueEl.textContent = game.score;
        }

        function updatePreviousScore() {
            previousScoreEl.textContent = game.previousScore;
        }

        function refreshHealthUI() {
            const percent = Math.max(0, Math.min(100, (game.health / game.maxHealth) * 100));
            healthBarEl.style.width = percent + '%';
            healthValueEl.textContent = Math.max(0, Math.floor(game.health));

            if (percent > 60) {
                healthBarEl.style.background = 'linear-gradient(90deg, #27ae60 0%, #2ecc71 50%, #27ae60 100%)';
                healthBarEl.style.boxShadow = '0 0 8px rgba(46, 204, 113, 0.4)';
            } else if (percent > 30) {
                healthBarEl.style.background = 'linear-gradient(90deg, #f39c12 0%, #f1c40f 50%, #f39c12 100%)';
                healthBarEl.style.boxShadow = '0 0 8px rgba(241, 196, 15, 0.4)';
            } else {
                healthBarEl.style.background = 'linear-gradient(90deg, #e74c3c 0%, #c0392b 50%, #e74c3c 100%)';
                healthBarEl.style.boxShadow = '0 0 8px rgba(231, 76, 60, 0.4)';
            }
            healthBarEl.style.backgroundSize = '20px 100%';
        }

        function updateHealth() {
            refreshHealthUI();
            if (game.health <= 0 && !gameOverPending) {
                handleGameOver();
            }
        }

        function handleGameOver() {
            gameOverPending = true;
            gameStarted = false;
            game.previousScore = game.score;
            updatePreviousScore();
            finalScoreEl.textContent = game.score;
            gameOverPreviousScoreEl.textContent = game.previousScore;
            gameOverOverlay.classList.add('show');
        }

        function findSafeSpawnPosition() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const searchRadius = Math.min(canvas.width, canvas.height) * 0.4;
            const attempts = 50;
            
            for (let i = 0; i < attempts; i++) {
                const angle = (i / attempts) * Math.PI * 2;
                const distance = (i / attempts) * searchRadius;
                const testX = centerX + Math.cos(angle) * distance;
                const testY = centerY + Math.sin(angle) * distance;
                
                if (testX >= player.size / 2 && testX <= canvas.width - player.size / 2 &&
                    testY >= player.size / 2 && testY <= canvas.height - player.size / 2) {
                    if (!checkCollision(testX, testY, player.size)) {
                        return { x: testX, y: testY };
                    }
                }
            }
            
            return { x: centerX, y: centerY };
        }

        function resetGame(resetPreviousScore = false) {
            if (resetPreviousScore) {
                game.previousScore = 0;
                updatePreviousScore();
            }
            game.score = 0;
            game.health = game.maxHealth;
            monsters.length = 0;
            missiles.length = 0;
            monsterSpawnTimer = 0;
            monsterSpawnInterval = 120;
            yellowMonsterTimer = 0;
            missileTimer = Math.floor(Math.random() * (missileSpawnInterval * 0.5));
            maxMonstersAllowed = 5;
            difficultyTimer = 0;
            player.attackAnimation = 0;
            player.attackCooldown = 0;
            player.weaponLevel = 1;
            player.attackDirection = { x: 1, y: 0 };
            player.invincible = false;
            player.invincibleTimer = 0;
            updateWeaponDisplay();
            initBackground();
            const safePos = findSafeSpawnPosition();
            player.x = safePos.x;
            player.y = safePos.y;
            updateScore();
            refreshHealthUI();
            gameOverOverlay.classList.remove('show');
            gameOverPending = false;
        }

        function attack() {
            if (!gameStarted || player.attackCooldown > 0 || gameOverPending) return;
            
            let attackDirX = game.touchDirection.x;
            let attackDirY = game.touchDirection.y;
            
            if (attackDirX === 0 && attackDirY === 0) {
                if (game.keys['ArrowUp'] || game.keys['w'] || game.keys['W']) attackDirY = -1;
                else if (game.keys['ArrowDown'] || game.keys['s'] || game.keys['S']) attackDirY = 1;
                if (game.keys['ArrowLeft'] || game.keys['a'] || game.keys['A']) attackDirX = -1;
                else if (game.keys['ArrowRight'] || game.keys['d'] || game.keys['D']) attackDirX = 1;
            }
            
            if (attackDirX === 0 && attackDirY === 0 && monsters.length > 0) {
                const nearestMonster = monsters.reduce((nearest, monster) => {
                    const dist = Math.hypot(player.x - monster.x, player.y - monster.y);
                    const nearestDist = Math.hypot(player.x - nearest.x, player.y - nearest.y);
                    return dist < nearestDist ? monster : nearest;
                }, monsters[0]);
                const dx = nearestMonster.x - player.x;
                const dy = nearestMonster.y - player.y;
                const dist = Math.hypot(dx, dy) || 1;
                    attackDirX = dx / dist;
                    attackDirY = dy / dist;
                }

            if (attackDirX === 0 && attackDirY === 0) {
                attackDirX = 1;
            }

            const dirLength = Math.hypot(attackDirX, attackDirY) || 1;
            player.attackDirection = { x: attackDirX / dirLength, y: attackDirY / dirLength };
            player.attackAnimation = ATTACK_ANIMATION_MAX;
            player.attackCooldown = Math.max(10, Math.floor(ATTACK_ANIMATION_MAX * 0.6));

            let hit = false;
            let hitYellowMonster = false;
            const charType = player.characterType;
            const profiles = weaponProfiles[charType];
            const profile = profiles[player.weaponLevel - 1];

            if (profile.splash && player.weaponLevel === 3 && charType === 'pink') {
                const meteorImpactX = player.x + player.attackDirection.x * profile.rangeMax;
                const meteorImpactY = player.y + player.attackDirection.y * profile.rangeMax;
                const splashRange = 35;
            
            for (let i = monsters.length - 1; i >= 0; i--) {
                const monster = monsters[i];
                    let isHit = false;
                    
                    const distToImpact = Math.hypot(monster.x - meteorImpactX, monster.y - meteorImpactY);
                    
                    if (distToImpact < splashRange + monster.size / 2) {
                        if (hasLineOfSight(meteorImpactX, meteorImpactY, monster.x, monster.y)) {
                            isHit = true;
                        }
                    }
                    
                    if (!isHit && isMonsterHitByAttack(monster)) {
                        isHit = true;
                    }
                    
                    if (isHit) {
                    if (monster.isYellow) {
                        hitYellowMonster = true;
                    }
                    monsters.splice(i, 1);
                    game.score += 1;
                    hit = true;
                }
            }
            } else {
                for (let i = monsters.length - 1; i >= 0; i--) {
                    const monster = monsters[i];
                    if (isMonsterHitByAttack(monster)) {
                        if (monster.isYellow) {
                            hitYellowMonster = true;
                        }
                        monsters.splice(i, 1);
                        game.score += 1;
                        hit = true;
                    }
                }
            }
            
            if (hit) {
                updateScore();
            }

            if (hitYellowMonster) {
                upgradeWeapon();
            }
        }

        function updatePlayer() {
            if (!gameStarted) return;

            if (player.attackAnimation > 0) {
                player.attackAnimation--;
            }
            
            if (player.attackCooldown > 0) {
                player.attackCooldown--;
            }
            
            // Î¨¥Ï†Å ÌÉÄÏù¥Î®∏ Í∞êÏÜå
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    player.invincibleTimer = 0;
                }
            }
            
            let moveX = 0;
            let moveY = 0;
            
            if (game.keys['ArrowUp'] || game.keys['w'] || game.keys['W']) moveY -= player.speed;
            if (game.keys['ArrowDown'] || game.keys['s'] || game.keys['S']) moveY += player.speed;
            if (game.keys['ArrowLeft'] || game.keys['a'] || game.keys['A']) moveX -= player.speed;
            if (game.keys['ArrowRight'] || game.keys['d'] || game.keys['D']) moveX += player.speed;

            if (game.touchDirection.x !== 0 || game.touchDirection.y !== 0) {
                moveX = game.touchDirection.x * player.speed;
                moveY = game.touchDirection.y * player.speed;
            }

            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071;
                moveY *= 0.7071;
            }

            let newX = player.x + moveX;
            let newY = player.y + moveY;
            
            if (moveX !== 0 && moveY !== 0) {
                if (checkCollision(newX, player.y, player.size) && !checkCollision(player.x, newY, player.size)) {
                    newX = player.x;
                } else if (checkCollision(player.x, newY, player.size) && !checkCollision(newX, player.y, player.size)) {
                    newY = player.y;
                }
            }
            
            if (!checkCollision(newX, newY, player.size)) {
                player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, newX));
                player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, newY));
            } else if (!checkCollision(newX, player.y, player.size)) {
                player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, newX));
            } else if (!checkCollision(player.x, newY, player.size)) {
                player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, newY));
            } else if (moveX !== 0 || moveY !== 0) {
                const slideX = moveX * 0.5;
                const slideY = moveY * 0.5;
                if (!checkCollision(player.x + slideX, player.y, player.size)) {
                    player.x = Math.max(player.size / 2, Math.min(canvas.width - player.size / 2, player.x + slideX));
                }
                if (!checkCollision(player.x, player.y + slideY, player.size)) {
                    player.y = Math.max(player.size / 2, Math.min(canvas.height - player.size / 2, player.y + slideY));
                }
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBackground();

            if (!gameStarted) {
                drawMonsters();
                drawMissiles();
            drawPlayer();
                requestAnimationFrame(gameLoop);
                return;
            }
            
            updatePlayer();

            if (!gameOverPending) {
            monsterSpawnTimer++;
                difficultyTimer++;
                yellowMonsterTimer++;
                missileTimer++;

                if (difficultyTimer >= difficultyIncreaseInterval && maxMonstersAllowed < maxMonstersCap) {
                    maxMonstersAllowed++;
                    difficultyTimer = 0;
                    if (monsterSpawnInterval > 70) {
                        monsterSpawnInterval -= 5;
                    }
                }

            if (monsterSpawnTimer >= monsterSpawnInterval) {
                spawnMonster();
                monsterSpawnTimer = 0;
                if (game.score > 50) {
                    spawnMonster();
                }
            }
            
            if (yellowMonsterTimer >= yellowMonsterInterval) {
                spawnMonster(true);
                yellowMonsterTimer = 0;
            }
            
            updateMonsters();
                updateMissiles();

                if (missileTimer >= missileSpawnInterval) {
                    spawnMissile();
                    missileTimer = 0;
                }
            } else {
                updateMissiles();
            }

            drawMonsters();
            drawMissiles();
            drawPlayer();
            
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', (event) => {
            game.keys[event.key] = true;
            if (event.key === ' ') {
                event.preventDefault();
                attack();
            }
        });

        document.addEventListener('keyup', (event) => {
            game.keys[event.key] = false;
        });

        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        const joystickRadius = 60;

        function updateJoystick(x, y) {
            if (!joystickBase) return;
            const rect = joystickBase.getBoundingClientRect();
            joystickCenter.x = rect.left + rect.width / 2;
            joystickCenter.y = rect.top + rect.height / 2;
            
            const dx = x - joystickCenter.x;
            const dy = y - joystickCenter.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > joystickRadius) {
                const angle = Math.atan2(dy, dx);
                const limitedX = joystickCenter.x + Math.cos(angle) * joystickRadius;
                const limitedY = joystickCenter.y + Math.sin(angle) * joystickRadius;
                joystickStick.style.transform = `translate(calc(-50% + ${limitedX - joystickCenter.x}px), calc(-50% + ${limitedY - joystickCenter.y}px))`;
                game.touchDirection.x = Math.cos(angle);
                game.touchDirection.y = Math.sin(angle);
            } else {
                joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                if (distance > 10) {
                    game.touchDirection.x = dx / joystickRadius;
                    game.touchDirection.y = dy / joystickRadius;
                } else {
                    game.touchDirection.x = 0;
                    game.touchDirection.y = 0;
                }
            }
        }

        function resetJoystick() {
            if (!joystickStick) return;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            game.touchDirection.x = 0;
            game.touchDirection.y = 0;
        }

        if (joystickBase) {
            joystickBase.addEventListener('touchstart', (event) => {
                event.preventDefault();
            joystickActive = true;
                updateJoystick(event.touches[0].clientX, event.touches[0].clientY);
        });

            joystickBase.addEventListener('touchmove', (event) => {
                event.preventDefault();
            if (joystickActive) {
                    updateJoystick(event.touches[0].clientX, event.touches[0].clientY);
            }
        });

            joystickBase.addEventListener('touchend', (event) => {
                event.preventDefault();
            joystickActive = false;
            resetJoystick();
        });

            joystickBase.addEventListener('touchcancel', (event) => {
                event.preventDefault();
            joystickActive = false;
            resetJoystick();
        });
        }

        if (attackButton) {
            attackButton.addEventListener('touchstart', (event) => {
                event.preventDefault();
            attack();
        });

            attackButton.addEventListener('click', (event) => {
                event.preventDefault();
            attack();
        });
        }

        restartButton.addEventListener('click', () => {
            resetGame();
            resetJoystick();
            gameOverOverlay.classList.remove('show');
            characterSelect.setAttribute('aria-hidden', 'true');
            gameOverPending = false;
            gameStarted = true;
        });

        changeCharacterButton.addEventListener('click', () => {
            resetGame();
            resetJoystick();
            gameOverOverlay.classList.remove('show');
            gameOverPending = false;
            gameStarted = false;
            characterOptions.forEach(opt => opt.classList.remove('selected'));
            characterSelect.classList.add('show');
            characterSelect.setAttribute('aria-hidden', 'false');
            setCharacterOptionsTabIndex('0');
        });

        resetGame(true);
        gameLoop();

        // Ï∫îÎ≤ÑÏä§ ÌÅ¥Î¶≠Ìï¥ÎèÑ Î∂ÄÎ™® divÎ•º ÌÅ¥Î¶≠Ìïú Í≤ÉÏ≤òÎüº ÎèôÏûëÌïòÍ≤å ÏúÑÏûÑ
        document.querySelectorAll('.character-sample').forEach(canvas => {
            canvas.addEventListener('click', (e) => {
                const parent = canvas.closest('.character-option');
                if (parent) parent.click(); // Î∂ÄÎ™® divÏùò ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ Í∞ïÏ†ú Ïã§Ìñâ
            });
            canvas.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    const parent = canvas.closest('.character-option');
                    if (parent) parent.click();
                }
            });
        });

        // 1. CSS pointer-events
        //const sampleStyle = document.createElement('style');
        //sampleStyle.innerHTML = `.character-sample { pointer-events: none !important; }`;
        //document.head.appendChild(sampleStyle);

        // 2. .character-option Ï†ëÍ∑ºÏÑ± ÏÜçÏÑ± Ï∂îÍ∞Ä
        characterOptions.forEach(option => {
            option.setAttribute('role', 'button');
            option.setAttribute('aria-pressed', 'false');
            option.setAttribute('tabindex', '0');
        });
        // (Ïù¥Î≤§Ìä∏ Îì±Î°ù Î°úÏßÅÏùÄ Í∏∞Ï°¥Í≥º ÎèôÏùº)

        // 3. canvas ÏúÑÏûÑ ÏΩîÎìúÎäî ÏôÑÏ†ÑÌûà ÏÇ≠Ï†ú
    </script>
</body>
</html>